<h1><code ng:non-bindable="">PublicApi</code>
<span class="hint">(api in module <code ng:non-bindable="">ui.grid.core</code>
)</span>
</h1>
<div><h2 id="Description">Description</h2>
<div class="description"><p>Public Api for the core grid features</p></div>
<div class="member method"><h2 id="Methods">Methods</h2>
<ul class="methods"><li><h3 id="clearRowInvisible">clearRowInvisible(rowEntity)</h3>
<div class="clearrowinvisible"><p>Clears any override on visibility for the row so that it returns to 
using normal filtering and other visibility calculations. <br />
If the row is currently invisible then sets it to visible and calls
both grid refresh and emits the rowsVisibleChanged event
TODO: if a filter is active then we can't just set it to visible?</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">rowEntity – {object} – </code>
<p>gridOptions.data[] array instance</p></li>
</ul>
</div>
</li>
<li><h3 id="getVisibleRows">getVisibleRows(grid)</h3>
<div class="getvisiblerows"><p>Returns all visible rows</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>the grid you want to get visible rows from</p></li>
</ul>
<h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{array}</code>
– <p>an array of gridRow </p></div>
</div>
</li>
<li><h3 id="refresh">refresh()</h3>
<div class="refresh"><p>Refresh the rendered grid on screen.</p></div>
</li>
<li><h3 id="refreshRows">refreshRows()</h3>
<div class="refreshrows"><p>Refresh the rendered grid on screen?  Note: not functional at present</p><h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{promise}</code>
– <p>promise that is resolved when render completes?</p></div>
</div>
</li>
<li><h3 id="renderingComplete">renderingComplete(gridApi)</h3>
<div class="renderingcomplete"><p>Rendering is complete, called at the same
time as <code>onRegisterApi</code>, but provides a way to obtain
that same event within features without stopping end
users from getting at the onRegisterApi method.</p>

<p>Included in gridApi so that it's always there - otherwise
there is still a timing problem with when a feature can
call this. </p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">gridApi – {GridApi} – </code>
<p>the grid api, as normally 
returned in the onRegisterApi method</p></li>
</ul>
<h4 id="Example">Example</h4>
<div class="example"><pre class="prettyprint linenums">
gridApi.core.on.renderingComplete( grid );
</pre></div>
</div>
</li>
<li><h3 id="setRowInvisible">setRowInvisible(rowEntity)</h3>
<div class="setrowinvisible"><p>Sets an override on the row to make it always invisible,
which will override any filtering or other visibility calculations. <br />
If the row is currently visible then sets it to invisible and calls
both grid refresh and emits the rowsVisibleChanged event</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">rowEntity – {object} – </code>
<p>gridOptions.data[] array instance</p></li>
</ul>
</div>
</li>
<li><h3 id="sortChanged">sortChanged(grid, sortColumns)</h3>
<div class="sortchanged"><p>The sort criteria on one or more columns has
changed.  Provides as parameters the grid and the output of
getColumnSorting, which is an array of gridColumns
that have sorting on them, sorted in priority order. </p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>the grid</p></li>
<li><code ng:non-bindable="">sortColumns – {array} – </code>
<p>an array of columns with 
sorts on them, in priority order</p></li>
</ul>
<h4 id="Example">Example</h4>
<div class="example"><pre class="prettyprint linenums">
gridApi.core.on.sortChanged( grid, sortColumns );
</pre></div>
</div>
</li>
</ul>
</div>
<div class="member event"><h2 id="Events">Events</h2>
<ul class="events"><li><h3 id="filterChanged">filterChanged</h3>
<div class="filterchanged"><p>is raised after the filter is changed.  The nature
of the watch expression doesn't allow notification of what changed,
so the receiver of this event will need to re-extract the filter 
conditions from the columns.</p><div class="inline"></div>
<div class="inline"></div>
</div>
</li>
<li><h3 id="rowsVisibleChanged">rowsVisibleChanged</h3>
<div class="rowsvisiblechanged"><p>is raised after the rows that are visible
change.  The filtering is zero-based, so it isn't possible
to say which rows changed (unlike in the selection feature).
We can plausibly know which row was changed when setRowInvisible
is called, but in that situation the user already knows which row
they changed.  When a filter runs we don't know what changed, 
and that is the one that would have been useful.</p><div class="inline"></div>
<div class="inline"></div>
</div>
</li>
</ul>
</div>
</div>
